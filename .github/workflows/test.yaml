name: Test

on:
  workflow_call:

jobs:
  _build:
    uses: ./.github/workflows/build.yaml

  _experiment:
    needs: _build
    runs-on: ubuntu-latest
    steps:
    - uses: actions/download-artifact@v4
      with:
        name: package.deb
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
    - run: sudo apt-get -y install ./package.deb
    - run: |
        export OTEL_SHELL_SDK_OUTPUT_REDIRECT=/dev/null
        export OTEL_SHELL_CONFIG_OBSERVE_SUBPROCESSES=TRUE
        . otel.sh

        list_version_files() {
          find . | grep -E '/VERSION$|/DEBIAN/control$|/package.json$|.toml$|.gemspec$'
        }

        is_version_touched() {
          local version_file="$1"
          local commit_id="$2"
          git diff "$commit_id"^ "$commit_id" -- "${version_file#./}" | { grep -E '^\+' || true; } | case "$version_file" in
            */VERSION) echo dirty;;
            */DEBIAN/control) grep -q 'Version: ' && echo dirty;;
            */package.json) grep -q '"version":' && echo dirty;;
            *.gemspec) grep -q '.version' && echo dirty;;
            *.toml) grep -q 'version' && echo dirty;;
            *) echo "Here be dragons! (version file $version_file)" >&2;;
          esac | grep -q dirty
        }
        
        read_version() {
          local version_file="$1"
          cat "$version_file" | case "$version_file" in
            */VERSION) cat;;
            */DEBIAN/control) grep -E '^Version: ' | cut -d ' ' -f 2-;;
            */package.json) jq -r .version;;
            *.gemspec) grep version | cut -d = -f 2 | awk '{ print $1 }' | tr -d "'"'"';;
            *.toml) grep version | cut -d = -f 2 | awk '{ print $1 }' | tr -d "'"'"';;
            *) echo "Here be dragons! (version file $version_file)" >&2; cat;;
          esac
        }
        
        write_version() {
          local version_file="$1"
          local version_string="$2"
          local version_string_new="$3"
          case "$version_file" in
            */VERSION) echo -n "$version_string_new" > "$version_file";;
            */DEBIAN/control) sed -i "s/^Version: .*/Version: $version_string_new/" "$version_file";;
            */package.json) jq --arg version "$version_string_new" '.version = $version' "$version_file" > tmp.$$.json && rm "$version_file" && mv tmp.$$.json "$version_file";;
            *.gemspec) sed -i "s/$version_string/$version_string_new/g" "$version_file";;
            *.toml) sed -i "s/$version_string/$version_string_new/g" "$version_file";;
            *) echo "Here be dragons! (version file $version_file)" >&2; return 1;;
          esac
        }

        increment_version() {
          local version_string="$1"
          local change_type="$2"
          major="$(echo "$version_string" | cut -d . -f 1)"
          minor="$(echo "$version_string" | cut -d . -f 2)"
          patch="$(echo "$version_string" | cut -d . -f 3)"
          if [ "$major.$minor.$patch" != "$version_string" ]; then echo "Version format not supported! ($version_string)" >&2; return 1; fi
          case "$change_type" in
            major) major="$((major + 1))"; minor=0; patch=0;;
            minor) minor="$((minor + 1))"; patch=0;;
            patch) patch="$((patch + 1))";;
            *) echo "Here be dragons! (change type $change_type)" >&2; return 1;;
          esac
          echo "$major.$minor.$patch"
        }

        set +e
        set +o pipefail
        export AI_SYSTEM_PROMPT="I take input that are commit messages and analyze whether the maximum change is either major, minor or patch. Major changes are for breaking changes, minor for new features, enhancements and optimizations, dependency updates, and other new functionality that does not break existing functionality, patch is for bug fixes only. Refactors do not need a version change. If the commit messages hint at more than one type of a change, I respond with the highest one. I only respond with major, minor, patch, or none if nothing at all need changing."
        list_version_files | while read -r version_file; do
          echo "processing $version_file ..." >&2
          directory="$(echo "$version_file" | rev | cut -d '/' -f 2- | rev)"/
          case "$version_file" in
            */DEBIAN/control) directory="$(echo "$directory" | rev | cut -d '/' -f 3- | rev)"/;;
            */package.json) if jq '.version' "$version_file" | grep -q null; then continue; fi;;
            *) true;;
          esac
          git log --oneline | cut -d ' ' -f 1 | while read -r commit_id; do
            if [ -n "$PATH_INCLUDE" ]; then
              skip=0
              IFS=:
              for path_include in $PATH_INCLUDE; do
                if ! git diff-tree --no-commit-id --name-only -r "$commit_id" | grep -qE '^'"${path_include#./}"; then skip=1; fi
              done
              IFS=' '
              if [ "$skip" = 1 ]; then continue; fi
            fi
            if [ -n "$PATH_EXCLUDE" ]; then
              skip=0
              IFS=:
              for path_exclude in $PATH_EXCLUDE; do
                if git diff-tree --no-commit-id --name-only -r "$commit_id" | grep -qE '^'"${path_exclude#./}"; then skip=1; fi
              done
              IFS=' '
              if [ "$skip" = 1 ]; then continue; fi
            fi
            if ! git diff-tree --no-commit-id --name-only -r "$commit_id" | grep -qE '^'"${directory#./}"; then continue; fi
            if git diff-tree --no-commit-id --name-only -r "$commit_id" | grep -qF "${version_file#./}" && is_version_touched "$version_file" "$commit_id"; then echo "stopping at $commit_id" >&2; break; fi
            echo "including $commit_id" >&2
            echo "$commit_id"
          done | while read -r commit_id; do git log -1 --format=%B "$commit_id"; done | grep -vE '^$' | xargs -r -0 ai | sort -u -r | while read -r change_type; do
            if [ "$change_type" = none ]; then continue; fi
            echo "bumping $change_type version in $version_file" >&2
            version_string="$(read_version "$version_file" || true)"
            if [ -z "$version_string" ]; then break; fi
            version_string_new="$(increment_version "$version_string" "$change_type" || true)"
            if [ -z "$version_string_new" ]; then break; fi
            write_version "$version_file" "$version_string" "$version_string_new" || true
          done
        done
    - run: git status
    - run: exit 1
  

  install:
    needs: _experiment
    runs-on: ubuntu-latest
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: package.deb
      - run: sudo apt-get -y install ./package.deb
      - run: sudo apt-get -y remove opentelemetry-shell

  smoke:
    needs: install
    runs-on: ubuntu-latest
    timeout-minutes: 180
    steps:
      - uses: actions/checkout@v4
      - uses: actions/download-artifact@v4
        with:
          name: package.deb
      - run: sudo -E apt-get -y install ./package.deb
      - run: bash -c "cd tests && bash run_tests.sh bash"

  upgrade-prepare:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.dynamic-matrix.outputs.matrix }}
    steps:
      - run: |
          curl --no-progress-meter --fail --retry 16 --retry-all-errors --header "Authorization: Bearer $GITHUB_TOKEN" --head https://api.github.com/repos/"$GITHUB_REPOSITORY"/releases?per_page=100 \
            | tr '[:upper:]' '[:lower:]' | grep '^link: ' | cut -d ' '  -f 2- | tr -d ' <>' | tr ',' '\n' | grep 'rel="last"' | cut -d ';' -f 1 | cut -d '?' -f 2- | tr '&' '\n' | grep '^page=' | cut -d = -f 2 \
            | xargs seq 1 | xargs -I '{}' curl --no-progress-meter --fail --retry 16 --retry-all-errors --header "Authorization: Bearer $GITHUB_TOKEN" https://api.github.com/repos/"$GITHUB_REPOSITORY"/releases?per_page=100\&page={} | jq -r '.[].tag_name' \
            | grep -v - | grep -v '^v1.0.0$' | grep -v '^v1.1.0$' | grep -v '^v1.12.6$' \
            | jq -nR '{"include": [inputs | select(length > 0) | {tag_name: .}]}' | tr -d '\n' | xargs -0 -I {} echo 'matrix={}' >> "$GITHUB_OUTPUT"
        id: dynamic-matrix
        env:
          GITHUB_TOKEN: ${{ github.token }}

  upgrade:
    needs: [upgrade-prepare, smoke]
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{ fromJSON(needs.upgrade-prepare.outputs.matrix) }}
    steps:
      - run: |
          curl --no-progress-meter --fail --retry 16 --retry-all-errors --header "Authorization: Bearer $GITHUB_TOKEN" https://api.github.com/repos/"$GITHUB_REPOSITORY"/releases/tags/${{ matrix.tag_name }} | jq -r '.assets[].browser_download_url' | xargs wget --header "Authorization: Bearer $GITHUB_TOKEN"
        env:
          GITHUB_TOKEN: ${{ github.token }}
      - run: sudo apt-get -y install ./*.deb
      - uses: actions/download-artifact@v4
        with:
          name: package.deb
      - run: sudo apt-get -y install ./package.deb

  system-upgrade:
    needs: [smoke]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        image: ['ubuntu:focal', 'ubuntu:latest', 'ubuntu:rolling']
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: package.deb
      - run: |
          echo '
            apt-get update
            apt-get -y install /root/package.deb 
            apt-get update && DEBIAN_FRONTEND=noninteractive apt-get -y dist-upgrade && apt-get -y autoremove && apt-get -y autoclean
            case "$(cat /etc/os-release | grep '^NAME=' | cut -d = -f 2 | tr -d "\"")" in
              Ubuntu)
                DEBIAN_FRONTEND=noninteractive apt-get -y install sed systemctl update-manager-core
                sed -i "/Prompt/d" /etc/update-manager/release-upgrades && echo "Prompt=normal" >> /etc/update-manager/release-upgrades
                do-release-upgrade -c || exit 0 && RELEASE_UPGRADER_ALLOW_THIRD_PARTY=1 do-release-upgrade -f DistUpgradeViewNonInteractive
                ;;
              Debian*)
                DEBIAN_FRONTEND=noninteractive apt-get -y install curl sed
                version_destination="$(curl -sL https://deb.debian.org/debian/dists/testing/InRelease | grep "^Codename:" | cut -d " " -f 2)"
                version_source="$(cat /etc/os-release | grep '^VERSION_CODENAME' | cut -d = -f 2)"
                sed -i "s/$version_source/$version_destination/g" /etc/apt/sources.list /etc/apt/sources.list.d/*
                sed -i "s/oldstable/testing/g" /etc/apt/sources.list /etc/apt/sources.list.d/*
                sed -i "s/stable/testing/g" /etc/apt/sources.list /etc/apt/sources.list.d/*
                ;;
              *) exit 1;;
            esac
            apt-get update && DEBIAN_FRONTEND=noninteractive apt-get -y dist-upgrade && apt-get -y autoremove && apt-get -y autoclean
          ' | sudo docker run -v $(pwd)/package.deb:/root/package.deb --rm --network=host -i --entrypoint=/bin/sh ${{ matrix.image }} -e

  dependency:
    needs: [smoke]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        image: ['debian:oldstable', 'debian:stable', 'debian:testing', 'debian:oldstable-slim', 'debian:stable-slim', 'debian:testing-slim', 'ubuntu:focal', 'ubuntu:latest', 'ubuntu:rolling']
        dependency: ['npm', 'gcc']
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: package.deb
      - run: |
          {
            echo 'apt-get update'
            echo 'apt-get -y remove ${{ matrix.dependency }}'
            echo 'DEBIAN_FRONTEND=noninteractive apt-get -y install /root/package.deb'
            echo 'DEBIAN_FRONTEND=noninteractive apt-get -y install ${{ matrix.dependency }}'
            echo 'apt-get -y remove ${{ matrix.dependency }}'
          } | sudo docker run -v $(pwd)/package.deb:/root/package.deb --rm --network=host -i --entrypoint=/bin/sh ${{ matrix.image }} -e

  os-shell:
    needs: smoke
    runs-on: ubuntu-latest
    strategy:
      matrix:
        os: ['debian:oldstable', 'debian:stable', 'debian:testing', 'debian:oldstable-slim', 'debian:stable-slim', 'debian:testing-slim', 'ubuntu:focal', 'ubuntu:latest', 'ubuntu:rolling']
        update: ['FALSE', 'TRUE']
        shell: [sh, dash, bash, busybox]
      fail-fast: true
    steps:
      - uses: actions/checkout@v4
      - uses: actions/download-artifact@v4
        with:
          name: package.deb
      - run: mv ./package.deb tests
      - run: bash -c 'cd tests && bash run_tests_containerized.sh "$OS" "$UPDATE" "$SHELL"'
        env:
          OS: ${{ matrix.os }}
          UPDATE: ${{ matrix.update }}
          SHELL: ${{ matrix.shell }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  action:
    needs: smoke
    runs-on: ubuntu-latest
    steps:
      - run: printenv | grep '^GITHUB_'
      - uses: actions/download-artifact@v4
        with:
          name: package.deb
      - run: sudo -E apt-get install ./package.deb
      - uses: actions/checkout@v4
      - uses: ./actions/instrument/job
        env:
          OTEL_METRICS_EXPORTER: console
          OTEL_LOGS_EXPORTER: console
          OTEL_TRACES_EXPORTER: console
      - run: echo hello world # check if simple command fails
      - run: sudo apt-get update
      - run: | # check if instrumentation happened
          [ "$(alias | grep '_otel_observe' | wc -l)" -gt 0 ]
      - run: | # check if traceparent is injected
          [ -n "$TRACEPARENT" ]
      - uses: actions/download-artifact@v4 # check if node action works
        with:
          name: package.deb
      - uses: actions/hello-world-docker-action@main # check if docker action works
      - uses: actions/first-interaction@v1 # node action with - in env vars
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          issue-message: "Hello, thanks for adding an issue for the first time!"
          pr-message: "Hello, thanks for contributing for the first time!"
      - uses: renovatebot/github-action@v40.3.3 # integration, node action with call to docker, docker flags that make injection more complicated, then call a node script via exec that already is injected with otel
        env:
          RENOVATE_DRY_RUN: full
          RENOVATE_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RENOVATE_REPOSITORIES: ${{ github.repository }}
          LOG_LEVEL: debug
      - uses: docker/setup-qemu-action@v3 # some docker actions have otel built-in
      - uses: docker/setup-buildx-action@v3 # some docker actions have otel built-in
      - run: cp package.deb tests/package.deb
      - uses: docker/build-push-action@v6 # some docker actions have otel built-in
        with:
          context: ./tests/
          tags: test
          push: false
          build-args: |
           image=ubuntu:latest
           update=TRUE
           shell=bash

  performance-prepare:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.dynamic-matrix.outputs.matrix }}
    steps:
      - run: |
          { echo '~local'; curl --no-progress-meter --fail --retry 16 --retry-all-errors --header "Authorization: Bearer $GITHUB_TOKEN" https://api.github.com/repos/"$GITHUB_REPOSITORY"/releases | jq -r .[].tag_name | head --lines=10; } | jq -nR '{"include": [inputs | select(length > 0) | {tag_name: .}]}' | tr -d '\n' | xargs -0 -I {} echo 'matrix={}' >> "$GITHUB_OUTPUT"
        id: dynamic-matrix
        env:
          GITHUB_TOKEN: ${{ github.token }}
  
  performance:
    needs: [performance-prepare, smoke]
    runs-on: ubuntu-latest
    strategy: 
      matrix: ${{ fromJSON(needs.performance-prepare.outputs.matrix) }}
    steps:
      - if: matrix.tag_name == '~local'
        uses: actions/download-artifact@v4
        with:
          name: package.deb
      - if: matrix.tag_name != '~local'
        run: |
          curl --no-progress-meter --fail --retry 16 --retry-all-errors --header "Authorization: Bearer $GITHUB_TOKEN" https://api.github.com/repos/"$GITHUB_REPOSITORY"/releases | jq -r '.[] | select(.tag_name == "${{ matrix.tag_name }}") | .assets[].browser_download_url' | grep '.deb$' | xargs wget --header "Authorization: Bearer $GITHUB_TOKEN"
        env:
          GITHUB_TOKEN: ${{ github.token }}
      - run: sudo apt-get install -y ./*.deb
      - run: |
          export OTEL_SHELL_SDK_OUTPUT_REDIRECT=/dev/null
          command time -f '%U' bash -c '. /usr/bin/opentelemetry_shell.sh' 2>> performance.${{ matrix.tag_name }}.coldstart.list
          for i in $(seq 1 100); do command time -f '%U' bash -c '. /usr/bin/opentelemetry_shell.sh' 2>> performance.${{ matrix.tag_name }}.warmstart.list; done
      - uses: actions/upload-artifact@v4
        with:
          name: performance.${{ matrix.tag_name }}.coldstart.list
          path: performance.${{ matrix.tag_name }}.coldstart.list
          retention-days: 1
      - uses: actions/upload-artifact@v4
        with:
          name: performance.${{ matrix.tag_name }}.warmstart.list
          path: performance.${{ matrix.tag_name }}.warmstart.list
          retention-days: 1

  join:
    needs: [install, upgrade, system-upgrade, dependency, os-shell, action, performance]
    runs-on: ubuntu-latest
    outputs:
      success: ${{ steps.tests.outputs.success }}
    steps:
      - id: tests
        run: echo "success=true" >> "$GITHUB_OUTPUT"

  all:
    if: ${{ always() }}
    needs: [join]
    runs-on: ubuntu-latest
    steps:
      - env:
          SUCCESS: ${{ needs.join.outputs.success }}
        run: |
          [ "$SUCCESS" = 'true' ]
      - uses: actions/download-artifact@v4
        with:
          pattern: 'performance.*.list'
          merge-multiple: true
      - run: |
          for file in performance.*.list; do
            type=$(echo $file | rev | cut -d . -f 2 | rev)
            version=$(echo $file | cut -d . -f 2- | rev | cut -d . -f 3- | rev)
            cat "$file" | grep -v 'No such file or directory' | sort -n | head -n 1 | xargs echo "$version" >> "$type".list
          done
      - run: |
          sudo apt-get update && sudo apt-get install -y gnuplot-nox
          echo '
            set terminal pngcairo enhanced font "Verdana,10" size 1024,1024
            set output "performance.png"
            set title "Performance Comparison"
            set xlabel "Version"
            set xtics rotate by -45
            set ylabel "Performance"
            set logscale y 10
            plot "coldstart.list" using 0:2:xticlabels(1) with linespoints title "Cold Start" lt rgb "blue", "warmstart.list" using 0:2:xticlabels(1) with linespoints title "Warm Start" lt rgb "red"
          ' > plot.gp
          gnuplot plot.gp
      - uses: actions/upload-artifact@v4
        with:
          name: performance.png
          path: performance.png
          retention-days: 90
