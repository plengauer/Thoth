name: Backport Bugfixes
on:
  push:
    branches:
      - main
jobs:
  backport:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read
      issues: read
      actions: read
    steps:
      - uses: actions/checkout@v5.0.0
        with:
          fetch-depth: 0
          token: ${{ secrets.ACTIONS_GITHUB_TOKEN }}
      
      - id: check
        env:
          GH_TOKEN: ${{ secrets.ACTIONS_GITHUB_TOKEN }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_TOKEN }}
        run: |
          set +e
          
          commit_sha="${{ github.sha }}"
          
          if [ "$(git diff-tree --no-commit-id --name-only -r "$commit_sha")" = "VERSION" ]; then
            echo "should_backport=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          
          should_backport=false
          
          echo "::group::Check for bug label"
          pr_number=$(gh pr list --state merged --search "$commit_sha" --json number --jq '.[0].number' 2>/dev/null)
          
          if [ -n "$pr_number" ] && [ "$pr_number" != "null" ]; then
            issue_number=$(gh pr view "$pr_number" --json body --jq '.body' | grep -oP '(?<=#)\d+' | head -1)
            
            if [ -n "$issue_number" ]; then
              if gh issue view "$issue_number" --json labels --jq '.labels[].name' | grep -qi "bug"; then
                should_backport=true
              fi
            fi
          fi
          echo "::endgroup::"
          
          if [ "$should_backport" = "false" ]; then
            echo "::group::AI analysis"
            cat > /tmp/prompt.txt <<EOF
          You are an expert at analyzing git commits to determine if they are bugfixes or patch-level changes.

          Analyze this git commit VERY CAREFULLY and determine if it is ONLY a bugfix or a patch-level dependency update that should be backported to a release branch.
          
          Consider:
          - Is this fixing a bug or defect in existing functionality?
          - Is this only updating dependencies to patch versions?
          - Does this introduce any new features or breaking changes?
          
          Return 'yes' if it should be backported (bugfix or patch-only dependency update), 'no' otherwise.
          
          Commit message:
          $(git log -1 --pretty=%B "$commit_sha")
          
          Diff summary:
          $(git show "$commit_sha" --stat)
          
          Think carefully and answer with just 'yes' or 'no':
          EOF
            
            if curl -sf https://api.openai.com/v1/chat/completions \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer $OPENAI_API_KEY" \
              -d "{
                \"model\": \"o1-preview\",
                \"messages\": [{\"role\": \"user\", \"content\": $(cat /tmp/prompt.txt | jq -Rs .)}],
                \"max_completion_tokens\": 10
              }" -o /tmp/ai_response.json; then
              
              if jq -e '.choices[0].message.content' /tmp/ai_response.json >/dev/null 2>&1; then
                ai_response=$(jq -r '.choices[0].message.content' /tmp/ai_response.json | tr '[:upper:]' '[:lower:]')
                
                if [ -n "$ai_response" ] && [ "$ai_response" != "null" ] && echo "$ai_response" | grep -q "yes"; then
                  should_backport=true
                fi
              fi
            fi
            echo "::endgroup::"
          fi
          
          echo "should_backport=$should_backport" >> "$GITHUB_OUTPUT"
          echo "commit_sha=$commit_sha" >> "$GITHUB_OUTPUT"
      
      - if: steps.check.outputs.should_backport == 'true'
        env:
          GH_TOKEN: ${{ secrets.ACTIONS_GITHUB_TOKEN }}
        run: |
          set -e
          
          commit_sha="${{ steps.check.outputs.commit_sha }}"
          current_version=$(cat VERSION)
          major=$(echo "$current_version" | cut -d. -f1)
          minor=$(echo "$current_version" | cut -d. -f2)
          release_branch="release/v${major}.${minor}"
          
          echo "::group::Create or checkout release branch"
          if git ls-remote --exit-code --heads origin "$release_branch" >/dev/null 2>&1; then
            git fetch origin "$release_branch"
            git checkout "$release_branch"
          else
            initial_tag="v${major}.${minor}.0"
            
            if git rev-parse "$initial_tag" >/dev/null 2>&1; then
              git checkout -b "$release_branch" "$initial_tag"
            else
              last_tag=$(git tag -l "v${major}.${minor}.*" | sort -V | tail -1)
              if [ -n "$last_tag" ]; then
                git checkout -b "$release_branch" "$last_tag"
              else
                main_version=$(git show main:VERSION)
                main_major=$(echo "$main_version" | cut -d. -f1)
                main_minor=$(echo "$main_version" | cut -d. -f2)
                
                if [ "$major" = "$main_major" ] && [ "$minor" = "$main_minor" ]; then
                  git checkout -b "$release_branch" main
                else
                  echo "::error::Cannot create release branch - no tag found for v${major}.${minor}.* and not current version"
                  exit 1
                fi
              fi
            fi
            
            git push -u origin "$release_branch"
          fi
          echo "::endgroup::"
          
          echo "release_branch=$release_branch" >> "$GITHUB_ENV"
          echo "commit_sha=$commit_sha" >> "$GITHUB_ENV"
      
      - if: steps.check.outputs.should_backport == 'true'
        run: |
          set -e
          
          echo "::group::Apply patch"
          git format-patch -1 "$commit_sha" --stdout > /tmp/commit.patch
          
          if grep -q "diff --git a/VERSION b/VERSION" /tmp/commit.patch; then
            if command -v filterdiff >/dev/null 2>&1; then
              filterdiff -x 'VERSION' /tmp/commit.patch > /tmp/commit_filtered.patch
              mv /tmp/commit_filtered.patch /tmp/commit.patch
            else
              awk '
                /^diff --git a\/VERSION b\/VERSION$/ { skip=1; next }
                /^diff --git / { skip=0 }
                !skip { print }
              ' /tmp/commit.patch > /tmp/commit_filtered.patch
              if [ -s /tmp/commit_filtered.patch ]; then
                mv /tmp/commit_filtered.patch /tmp/commit.patch
              fi
            fi
          fi
          
          if [ -s /tmp/commit.patch ] && git apply --check /tmp/commit.patch 2>/dev/null; then
            git apply /tmp/commit.patch
          elif [ -s /tmp/commit.patch ]; then
            original_version=$(cat VERSION)
            if git cherry-pick -n "$commit_sha" 2>/dev/null; then
              echo "$original_version" > VERSION
              git add VERSION
            else
              git cherry-pick --abort 2>/dev/null || true
              echo "::error::Cherry-pick failed - conflicts need manual resolution for commit $commit_sha"
              exit 1
            fi
          else
            exit 0
          fi
          echo "::endgroup::"
      
      - if: steps.check.outputs.should_backport == 'true'
        id: resolve_reviewers
        env:
          GH_TOKEN: ${{ secrets.ACTIONS_GITHUB_TOKEN }}
        run: |
          set -e
          
          echo "::group::Resolve reviewers and commit info"
          commit_sha="${{ steps.check.outputs.commit_sha }}"
          
          commit_title=$(git log -1 --pretty=%s "$commit_sha")
          echo "commit_title=$commit_title" >> "$GITHUB_OUTPUT"
          
          pr_number=$(gh pr list --state merged --search "$commit_sha" --json number --jq '.[0].number' 2>/dev/null)
          
          reviewers=""
          author=""
          
          if [ -n "$pr_number" ] && [ "$pr_number" != "null" ]; then
            author=$(gh pr view "$pr_number" --json author --jq '.author.login' 2>/dev/null || echo "")
            pr_reviewers=$(gh pr view "$pr_number" --json reviews --jq '.reviews[].author.login' 2>/dev/null | sort -u | tr '\n' ',' || echo "")
            reviewers="${pr_reviewers%,}"
          fi
          
          if [ -z "$author" ]; then
            author=$(git log -1 --pretty=%an "$commit_sha" 2>/dev/null || echo "")
          fi
          
          if [ -n "$author" ]; then
            if [ -n "$reviewers" ]; then
              reviewers="${author},${reviewers}"
            else
              reviewers="$author"
            fi
          fi
          
          if [ -f .github/renovate.json ]; then
            renovate_reviewers=$(cat .github/renovate.json | jq -r '.reviewers | join(",")' 2>/dev/null || echo "")
            if [ -n "$renovate_reviewers" ]; then
              if [ -n "$reviewers" ]; then
                reviewers="${reviewers},${renovate_reviewers}"
              else
                reviewers="$renovate_reviewers"
              fi
            fi
          fi
          
          echo "reviewers=$reviewers" >> "$GITHUB_OUTPUT"
          echo "::endgroup::"
      
      - if: steps.check.outputs.should_backport == 'true'
        uses: peter-evans/create-pull-request@v7.0.8
        with:
          token: ${{ secrets.ACTIONS_GITHUB_TOKEN }}
          commit-message: |
            Backport: ${{ steps.resolve_reviewers.outputs.commit_title }}
            
            Original commit: ${{ steps.check.outputs.commit_sha }}
          base: ${{ env.release_branch }}
          branch: backport/${{ steps.check.outputs.commit_sha }}
          title: "Backport: ${{ steps.resolve_reviewers.outputs.commit_title }}"
          body: |
            Automated backport of commit ${{ steps.check.outputs.commit_sha }}
          reviewers: ${{ steps.resolve_reviewers.outputs.reviewers }}
          delete-branch: true
