name: Backport Bugfixes
on:
  push:
    branches:
      - main
jobs:
  backport:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read
      issues: read
      actions: read
    steps:
      - uses: actions/checkout@v5.0.0
        with:
          fetch-depth: 0
          token: ${{ secrets.ACTIONS_GITHUB_TOKEN }}
      
      - id: check
        env:
          GH_TOKEN: ${{ secrets.ACTIONS_GITHUB_TOKEN }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_TOKEN }}
        run: |
          set +e
          
          commit_sha="${{ github.sha }}"
          
          if [ "$(git diff-tree --no-commit-id --name-only -r "$commit_sha")" = "VERSION" ]; then
            echo "should_backport=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          
          should_backport=false
          reason=""
          
          echo "::group::Check for bug label"
          pr_number=$(gh pr list --state merged --search "$commit_sha" --json number --jq '.[0].number' 2>/dev/null)
          
          if [ -n "$pr_number" ] && [ "$pr_number" != "null" ]; then
            issue_number=$(gh pr view "$pr_number" --json body --jq '.body' | grep -oP '(?<=#)\d+' | head -1)
            
            if [ -n "$issue_number" ]; then
              if gh issue view "$issue_number" --json labels --jq '.labels[].name' | grep -qi "bug"; then
                should_backport=true
                reason="Issue #$issue_number has bug label"
              fi
            fi
          fi
          echo "::endgroup::"
          
          if [ "$should_backport" = "false" ]; then
            echo "::group::AI analysis"
            cat > /tmp/prompt.txt <<EOF
          Analyze this git commit and determine if it is ONLY a bugfix or a patch-level dependency update that should be backported to a release branch. Return 'yes' if it should be backported (bugfix or patch-only dependency update), 'no' otherwise.
          
          Commit message:
          $(git log -1 --pretty=%B "$commit_sha")
          
          Diff summary:
          $(git show "$commit_sha" --stat)
          
          Answer with just 'yes' or 'no':
          EOF
            
            if curl -sf https://api.openai.com/v1/chat/completions \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer $OPENAI_API_KEY" \
              -d "{
                \"model\": \"gpt-4o\",
                \"messages\": [{\"role\": \"user\", \"content\": $(cat /tmp/prompt.txt | jq -Rs .)}],
                \"temperature\": 0.1,
                \"max_tokens\": 10
              }" -o /tmp/ai_response.json; then
              
              if jq -e '.choices[0].message.content' /tmp/ai_response.json >/dev/null 2>&1; then
                ai_response=$(jq -r '.choices[0].message.content' /tmp/ai_response.json | tr '[:upper:]' '[:lower:]')
                
                if [ -n "$ai_response" ] && [ "$ai_response" != "null" ] && echo "$ai_response" | grep -q "yes"; then
                  should_backport=true
                  reason="AI determined this is a bugfix or patch-only update"
                fi
              fi
            fi
            echo "::endgroup::"
          fi
          
          echo "should_backport=$should_backport" >> "$GITHUB_OUTPUT"
          echo "reason=$reason" >> "$GITHUB_OUTPUT"
          echo "commit_sha=$commit_sha" >> "$GITHUB_OUTPUT"
      
      - if: steps.check.outputs.should_backport == 'true'
        env:
          GH_TOKEN: ${{ secrets.ACTIONS_GITHUB_TOKEN }}
        run: |
          set -e
          
          commit_sha="${{ steps.check.outputs.commit_sha }}"
          current_version=$(cat VERSION)
          major=$(echo "$current_version" | cut -d. -f1)
          minor=$(echo "$current_version" | cut -d. -f2)
          release_branch="release/v${major}.${minor}"
          
          echo "::group::Create or checkout release branch"
          if git ls-remote --exit-code --heads origin "$release_branch" >/dev/null 2>&1; then
            git fetch origin "$release_branch"
            git checkout "$release_branch"
          else
            initial_tag="v${major}.${minor}.0"
            
            if git rev-parse "$initial_tag" >/dev/null 2>&1; then
              git checkout -b "$release_branch" "$initial_tag"
            else
              last_tag=$(git tag -l "v${major}.${minor}.*" | sort -V | tail -1)
              if [ -n "$last_tag" ]; then
                git checkout -b "$release_branch" "$last_tag"
              else
                main_version=$(git show main:VERSION)
                main_major=$(echo "$main_version" | cut -d. -f1)
                main_minor=$(echo "$main_version" | cut -d. -f2)
                
                if [ "$major" = "$main_major" ] && [ "$minor" = "$main_minor" ]; then
                  git checkout -b "$release_branch" main
                else
                  echo "::error::Cannot create release branch - no tag found for v${major}.${minor}.* and not current version"
                  exit 1
                fi
              fi
            fi
            
            git push -u origin "$release_branch"
          fi
          echo "::endgroup::"
          
          echo "release_branch=$release_branch" >> "$GITHUB_ENV"
          echo "commit_sha=$commit_sha" >> "$GITHUB_ENV"
      
      - if: steps.check.outputs.should_backport == 'true'
        run: |
          set -e
          
          echo "::group::Apply patch"
          git format-patch -1 "$commit_sha" --stdout > /tmp/commit.patch
          
          if grep -q "diff --git a/VERSION b/VERSION" /tmp/commit.patch; then
            if command -v filterdiff >/dev/null 2>&1; then
              filterdiff -x 'VERSION' /tmp/commit.patch > /tmp/commit_filtered.patch
              mv /tmp/commit_filtered.patch /tmp/commit.patch
            else
              awk '
                /^diff --git a\/VERSION b\/VERSION$/ { skip=1; next }
                /^diff --git / { skip=0 }
                !skip { print }
              ' /tmp/commit.patch > /tmp/commit_filtered.patch
              if [ -s /tmp/commit_filtered.patch ]; then
                mv /tmp/commit_filtered.patch /tmp/commit.patch
              fi
            fi
          fi
          
          if [ -s /tmp/commit.patch ] && git apply --check /tmp/commit.patch 2>/dev/null; then
            git apply /tmp/commit.patch
          elif [ -s /tmp/commit.patch ]; then
            original_version=$(cat VERSION)
            if git cherry-pick -n "$commit_sha" 2>/dev/null; then
              echo "$original_version" > VERSION
              git add VERSION
            else
              git cherry-pick --abort 2>/dev/null || true
              echo "::error::Cherry-pick failed - conflicts need manual resolution for commit $commit_sha"
              exit 1
            fi
          else
            exit 0
          fi
          echo "::endgroup::"
      
      - if: steps.check.outputs.should_backport == 'true'
        run: |
          set -e
          
          echo "::group::Commit and push"
          git add -A
          commit_msg=$(git log -1 --pretty=%B "$commit_sha" | head -1)
          reason="${{ steps.check.outputs.reason }}"
          git commit -m "Backport: $commit_msg" -m "Original commit: $commit_sha" -m "Reason: $reason"
          git push origin "$release_branch"
          echo "::endgroup::"
