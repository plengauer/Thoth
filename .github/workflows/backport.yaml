name: Backport
on:
  push:
    branches:
      - main
jobs:
  backport:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read
      issues: read
      actions: read
    steps:
      - uses: actions/checkout@v5.0.0
        with:
          fetch-depth: 0
          token: ${{ secrets.ACTIONS_GITHUB_TOKEN }}
          path: repo
      
          echo "commit_sha=$commit_sha" >> "$GITHUB_OUTPUT"
      
      - id: autoversion
        uses: plengauer/autoversion@v1.2.0
        with:
          github_token: ${{ secrets.ACTIONS_GITHUB_TOKEN }}
          openai_token: ${{ secrets.OPENAI_TOKEN }}
          path_include: ./repo/src:./repo/actions
          dry_run: true
          depth: 1
          working_directory: ./repo
      
      - id: check_patch
        working-directory: ./repo
        run: |
          set -e
          
          echo "::group::Check if only patch version changed"
          old_version=$(git show HEAD~1:VERSION 2>/dev/null || echo "0.0.0")
          new_version=$(cat VERSION)
          
          old_major=$(echo "$old_version" | cut -d. -f1)
          old_minor=$(echo "$old_version" | cut -d. -f2)
          new_major=$(echo "$new_version" | cut -d. -f1)
          new_minor=$(echo "$new_version" | cut -d. -f2)
          
          if [ "$old_major" = "$new_major" ] && [ "$old_minor" = "$new_minor" ] && [ "$old_version" != "$new_version" ]; then
            echo "should_backport=true" >> "$GITHUB_OUTPUT"
          else
            echo "should_backport=false" >> "$GITHUB_OUTPUT"
          fi
          echo "::endgroup::"
      
      - if: steps.check_patch.outputs.should_backport == 'true'
        working-directory: ./repo
        env:
          GH_TOKEN: ${{ secrets.ACTIONS_GITHUB_TOKEN }}
        run: |
          set -e
          
          commit_sha="${{ steps.check.outputs.commit_sha }}"
          current_version=$(cat VERSION)
          major=$(echo "$current_version" | cut -d. -f1)
          minor=$(echo "$current_version" | cut -d. -f2)
          release_branch="release/v${major}.${minor}"
          
          echo "::group::Create or checkout release branch"
          if git ls-remote --exit-code --heads origin "$release_branch" >/dev/null 2>&1; then
            git fetch origin "$release_branch"
            git checkout "$release_branch"
          else
            initial_tag="v${major}.${minor}.0"
            
            if git rev-parse "$initial_tag" >/dev/null 2>&1; then
              git checkout -b "$release_branch" "$initial_tag"
            else
              last_tag=$(git tag -l "v${major}.${minor}.*" | sort -V | tail -1)
              if [ -n "$last_tag" ]; then
                git checkout -b "$release_branch" "$last_tag"
              else
                main_version=$(git show main:VERSION)
                main_major=$(echo "$main_version" | cut -d. -f1)
                main_minor=$(echo "$main_version" | cut -d. -f2)
                
                if [ "$major" = "$main_major" ] && [ "$minor" = "$main_minor" ]; then
                  git checkout -b "$release_branch" main
                else
                  echo "::error::Cannot create release branch - no tag found for v${major}.${minor}.* and not current version"
                  exit 1
                fi
              fi
            fi
            
            git push -u origin "$release_branch"
          fi
          echo "::endgroup::"
          
          echo "release_branch=$release_branch" >> "$GITHUB_ENV"
          echo "commit_sha=$commit_sha" >> "$GITHUB_ENV"
      
      - if: steps.check_patch.outputs.should_backport == 'true'
        working-directory: ./repo
        run: |
          set -e
          
          echo "::group::Apply patch"
          git format-patch -1 "$commit_sha" --stdout > /tmp/commit.patch
          
          if grep -q "diff --git a/VERSION b/VERSION" /tmp/commit.patch; then
            if command -v filterdiff >/dev/null 2>&1; then
              filterdiff -x 'VERSION' /tmp/commit.patch > /tmp/commit_filtered.patch
              mv /tmp/commit_filtered.patch /tmp/commit.patch
            else
              awk '
                /^diff --git a\/VERSION b\/VERSION$/ { skip=1; next }
                /^diff --git / { skip=0 }
                !skip { print }
              ' /tmp/commit.patch > /tmp/commit_filtered.patch
              if [ -s /tmp/commit_filtered.patch ]; then
                mv /tmp/commit_filtered.patch /tmp/commit.patch
              fi
            fi
          fi
          
          if [ -s /tmp/commit.patch ] && git apply --check /tmp/commit.patch 2>/dev/null; then
            git apply /tmp/commit.patch
          elif [ -s /tmp/commit.patch ]; then
            original_version=$(cat VERSION)
            if git cherry-pick -n "$commit_sha" 2>/dev/null; then
              echo "$original_version" > VERSION
              git add VERSION
            else
              git cherry-pick --abort 2>/dev/null || true
              echo "::error::Cherry-pick failed - conflicts need manual resolution for commit $commit_sha"
              exit 1
            fi
          else
            exit 0
          fi
          echo "::endgroup::"
      
      - id: resolve_reviewers
        working-directory: ./repo
        env:
          GH_TOKEN: ${{ secrets.ACTIONS_GITHUB_TOKEN }}
        run: |
          set -e
          
          echo "::group::Resolve reviewers and commit info"
          commit_sha="${{ steps.check.outputs.commit_sha }}"
          
          commit_title=$(git log -1 --pretty=%s "$commit_sha")
          echo "commit_title=$commit_title" >> "$GITHUB_OUTPUT"
          
          pr_number=$(gh pr list --state merged --search "$commit_sha" --json number --jq '.[0].number' 2>/dev/null)
          
          reviewers=""
          author=""
          
          if [ -n "$pr_number" ] && [ "$pr_number" != "null" ]; then
            author=$(gh pr view "$pr_number" --json author --jq '.author.login' 2>/dev/null || echo "")
            pr_reviewers=$(gh pr view "$pr_number" --json reviews --jq '.reviews[].author.login' 2>/dev/null | sort -u | tr '\n' ',' || echo "")
            reviewers="${pr_reviewers%,}"
          fi
          
          if [ -z "$author" ]; then
            author=$(git log -1 --pretty=%an "$commit_sha" 2>/dev/null || echo "")
          fi
          
          author_email=$(git log -1 --pretty=%ae "$commit_sha" 2>/dev/null || echo "")
          author_name=$(git log -1 --pretty=%an "$commit_sha" 2>/dev/null || echo "")
          
          if [ -n "$author" ]; then
            if [ -n "$reviewers" ]; then
              reviewers="${author},${reviewers}"
            else
              reviewers="$author"
            fi
          fi
          
          if [ -f .github/renovate.json ]; then
            renovate_reviewers=$(jq -r '.reviewers | join(",")' .github/renovate.json 2>/dev/null || echo "")
            if [ -n "$renovate_reviewers" ]; then
              if [ -n "$reviewers" ]; then
                reviewers="${reviewers},${renovate_reviewers}"
              else
                reviewers="$renovate_reviewers"
              fi
            fi
          fi
          
          echo "reviewers=$reviewers" >> "$GITHUB_OUTPUT"
          echo "author_name=$author_name" >> "$GITHUB_OUTPUT"
          echo "author_email=$author_email" >> "$GITHUB_OUTPUT"
          echo "::endgroup::"
      
      - uses: peter-evans/create-pull-request@v7.0.8
        with:
          token: ${{ secrets.ACTIONS_GITHUB_TOKEN }}
          path: ./repo
          commit-message: |
            Backport: ${{ steps.resolve_reviewers.outputs.commit_title }}
            
            Original commit: ${{ steps.check.outputs.commit_sha }}
          co-authors: ${{ steps.resolve_reviewers.outputs.author_name }} <${{ steps.resolve_reviewers.outputs.author_email }}>
          base: ${{ env.release_branch }}
          branch: backport/${{ steps.check.outputs.commit_sha }}
          title: "Backport: ${{ steps.resolve_reviewers.outputs.commit_title }}"
          body: |
            Automated backport of commit ${{ steps.check.outputs.commit_sha }}
          reviewers: ${{ steps.resolve_reviewers.outputs.reviewers }}
          delete-branch: true
